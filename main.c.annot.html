<!DOCTYPE html>
<html>
<head>
<title>Annotated source listing for\/auto/d/de-sousa/SIM203/arbres-couvrants/main.c</title>
<style>
*{margin:0;padding:0}body,html{color:#000;background:#fff;height:100%;width:100%;font-family:"Lucida Sans Unicode","Lucida Grande",sans-serif;overflow:hidden}.header{position:absolute;top:0;height:50px;width:100%;background:#0071c5;color:#fff}.content{position:absolute;left:0;right:0;width:75%;top:50px;bottom:40px;margin:0 auto}.content .inner_header{height:30px;background:#ddd}.content .scrollable_right{position:absolute;left:300px;bottom:0;top:30px;right:0;overflow-y:scroll;padding:3px 5px}.content .scrollable_left{overflow-y:scroll;position:absolute;width:285px;top:30px;bottom:0;padding:3px 5px;border-left:thick solid #ddd}.footer{position:absolute;bottom:0;height:40px;width:100%;background:#0071c5;text-align:center;color:#fff}.header .title{position:relative;padding:7px 5px;left:12.5%;color:#fff;font-size:20px;font-weight:bolder;text-shadow:1px 1px #000}.content .title{padding:3px 5px;color:#0071c5;font-size:14px;font-weight:bolder}.footer .title{padding:10px;font-size:12px}.content .scrollable_left .annot_link{font-size:14px;color:#0071c5}.content .scrollable_left .annot_link:visited {color:purple;text-decoration:underline;}.footnote{color: #0071c5;}</style>
</head>
<body>
<div class="header">
<div class="title">Annotated source listing with compiler optimization reports</div>
</div>
<div class="content">
<div class="inner_header">
<div class="title">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c
</div>
</div><div class="scrollable_left"><h5 style="color:#032640">Routines with optimization reports</h5><a class="annot_link" href="#l17">main()</a><br/></div><div class="scrollable_right" id="code_layout">
 <pre style="border-width:0px;"></pre><pre style="display:inline-block;padding:5px;margin-right:3px;font-color:#AEAEAEk;font-size:11px;border-radius:12px;border:1px solid #dddddd; background:#fbfbfb">
INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: 230
  -inline-max-total-size: 2000
  -inline-max-per-routine: 10000
  -inline-max-per-compile: 500000

</pre>
<pre style="border-width:0px;"><a id="l1">1	// Compilation:
</a><a id="l2">2	//    icc -std=c99 -mkl main.c citiesReader.c
</a><a id="l3">3	//    icc -std=c99 -mkl -qopt-report=1 -qopt-report-annotate=html main.c citiesReader.c
</a><a id="l4">4	// Execution:
</a><a id="l5">5	//   ./a.out
</a><a id="l6">6	
</a><a id="l7">7	#include "citiesReader.h"
</a><a id="l8">8	
</a><a id="l9">9	#include &lt;stdlib.h&gt;
</a><a id="l10">10	#include &lt;stdio.h&gt;
</a><a id="l11">11	#include &lt;string.h&gt;
</a><a id="l12">12	#include &lt;stdbool.h&gt;
</a><a id="l13">13	#include &lt;float.h&gt;
</a><a id="l14">14	#include &lt;math.h&gt;
</a><a id="l15">15	#include &lt;mkl.h&gt;
</a><a id="l16">16	
</a><a id="l17">17	int main() {
</a></pre><pre style="display:inline-block;padding:5px;margin-right:3px;font-color:#AEAEAEk;font-size:11px;border-radius:12px;border:1px solid #dddddd; background:#fbfbfb">
INLINE REPORT: (main()) [1] <a class="annot_link" href="main.c.annot.html#l17">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(17,12)</a>
  -&gt; INLINE: <a class="annot_link" href="main.c.annot.html#l236">(236,23)</a> atoi(const char *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -&gt; INLINE: <a class="annot_link" href="main.c.annot.html#l238">(238,25)</a> atof(const char *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -&gt; INLINE: <a class="annot_link" href="main.c.annot.html#l240">(240,25)</a> atof(const char *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -&gt; INLINE: <a class="annot_link" href="main.c.annot.html#l247">(247,24)</a> atoi(const char *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -&gt; INLINE: <a class="annot_link" href="main.c.annot.html#l249">(249,24)</a> atoi(const char *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}

<a class="annot_link" href="main.c.annot.html#l17">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(17,12)</a>:remark #34051: REGISTER ALLOCATION : [main] /auto/d/de-sousa/SIM203/arbres-couvrants/main.c:17

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rsi rdi r8-r9 r12-r15 zmm0-zmm3]
        
    Routine temporaries
        Total         :     412
            Global    :     155
            Local     :     257
        Regenerable   :     118
        Spilled       :      27
        
    Routine stack
        Variables     :     754 bytes*
            Reads     :       7 [2.77e-01 ~ 0.3%]
            Writes    :       3 [5.66e-02 ~ 0.1%]
        Spills        :     176 bytes*
            Reads     :      46 [3.21e+00 ~ 3.2%]
            Writes    :      43 [2.76e+00 ~ 2.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

</pre>
<pre style="border-width:0px;"><a id="l18">18	
</a><a id="l19">19	  int popMin;
</a><a id="l20">20	  printf("Minimal population? ");
</a><a id="l21">21	  scanf("%i", &popMin);
</a><a id="l22">22	
</a><a id="l23">23	
</a><a id="l24">24	  ListOfCities* cities;
</a><a id="l25">25	  float taille_reseau = 0;
</a><a id="l26">26	  int nb_villes = 0;
</a><a id="l27">27	  double time = 0;
</a><a id="l28">28	
</a><a id="l29">29	  for(int dpt = 1; dpt&lt;95; dpt++){
</a></pre><pre style="display:inline-block;padding:5px;margin-right:3px;font-color:#AEAEAEk;font-size:11px;border-radius:12px;border:1px solid #dddddd; background:#fbfbfb">


Non-optimizable loops:


LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l29">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(29,3)</a>
   remark #15543: loop was not vectorized: loop with function call not considered an optimization candidate.

   LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l52">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(52,5)</a>
      remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   LOOP END

   LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l59">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(59,5)</a>
      remark #15543: loop was not vectorized: loop with function call not considered an optimization candidate.

      LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l73">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(73,7)</a>
         remark #15523: loop was not vectorized: loop control variable j was found, but loop iteration count cannot be computed before executing the loop
      LOOP END
   LOOP END

   LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l97">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(97,5)</a>
      remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   LOOP END

   LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l103">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(103,5)</a>
      remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END
</pre>
<pre style="border-width:0px;"><a id="l30">30	//-----------------------------------------------------------------
</a><a id="l31">31	//--- READING cities from departement = dpt
</a><a id="l32">32	//-----------------------------------------------------------------
</a><a id="l33">33	    char outputFile[50];
</a><a id="l34">34	    sprintf(outputFile,"resuCities_%d.dat",dpt);
</a><a id="l35">35	    cities = citiesReader(popMin,dpt,outputFile);
</a><a id="l36">36	    nb_villes += cities-&gt;number;
</a><a id="l37">37	
</a><a id="l38">38	    //TEMPS DE CALCUL: entrée dans l'algo
</a><a id="l39">39	    unsigned MKL_INT64 t0;
</a><a id="l40">40	    mkl_get_cpu_clocks(&t0);
</a><a id="l41">41	//-----------------------------------------------------------------
</a><a id="l42">42	//--- COMPUTING graph
</a><a id="l43">43	//----------------------------------------------------------------- 
</a><a id="l44">44	    // allocation des variables
</a><a id="l45">45	    bool* dansS = malloc(cities-&gt;number*sizeof(bool));
</a><a id="l46">46	    int* voisin = malloc(cities-&gt;number*sizeof(int));
</a><a id="l47">47	    float* dist = malloc(cities-&gt;number*sizeof(float));
</a><a id="l48">48	
</a><a id="l49">49	    //Initialisation
</a><a id="l50">50	    dansS[0] = true;  //On démarre du sommet 0
</a><a id="l51">51	    dist[0] = 0;      //dist(0,0) = 0
</a><a id="l52">52	    for(int i = 0; i &lt; cities-&gt;number; i++){
</a><a id="l53">53	      dansS[i] = false;
</a><a id="l54">54	      dist[i] = poids(cities,0,i);
</a><a id="l55">55	      voisin[i] = 0;
</a><a id="l56">56	    }
</a><a id="l57">57	    //Itérations
</a><a id="l58">58	    int k = 0;
</a><a id="l59">59	    while(k &lt; cities-&gt;number - 2){
</a><a id="l60">60	      //Trouver i tels que (dansS[i]=false) et (dist[i] est minimal)
</a><a id="l61">61	      float minDist = FLT_MAX;
</a><a id="l62">62	      int i = 0;
</a><a id="l63">63	      for(int j = 1; j &lt; cities-&gt;number; j++){
</a></pre><pre style="display:inline-block;padding:5px;margin-right:3px;font-color:#AEAEAEk;font-size:11px;border-radius:12px;border:1px solid #dddddd; background:#fbfbfb">

LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l63">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(63,7)</a>
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l63">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(63,7)</a>
&lt;Remainder&gt;
LOOP END
</pre>
<pre style="border-width:0px;"><a id="l64">64	        if( dansS[j] == false){
</a><a id="l65">65	          if(dist[j] &lt; minDist){
</a><a id="l66">66	            minDist = dist[j];
</a><a id="l67">67	            i = j;
</a><a id="l68">68	          }
</a><a id="l69">69	        }
</a><a id="l70">70	      }
</a><a id="l71">71	      dansS[i] = true;
</a><a id="l72">72	      
</a><a id="l73">73	      for(int j = 0; j &lt; cities-&gt;number; j++){
</a><a id="l74">74	        if( dansS[j] == false ){
</a><a id="l75">75	          if( dist[j] &gt; poids(cities,i,j) ){
</a><a id="l76">76	            dist[j] = poids(cities,i,j);
</a><a id="l77">77	            voisin[j] = i;
</a><a id="l78">78	          }
</a><a id="l79">79	        }
</a><a id="l80">80	      }
</a><a id="l81">81	      k ++;
</a><a id="l82">82	    }
</a><a id="l83">83	//-----------------------------------------------------------------
</a><a id="l84">84	//--- GRAPH COMPUTED
</a><a id="l85">85	//-----------------------------------------------------------------
</a><a id="l86">86	    //TEMPS DE CALCUL: sortie de l'algo
</a><a id="l87">87	    unsigned MKL_INT64 t1;
</a><a id="l88">88	    mkl_get_cpu_clocks(&t1);
</a><a id="l89">89	    time += (double)(t1-t0)/mkl_get_clocks_frequency();
</a><a id="l90">90	
</a><a id="l91">91	//-----------------------------------------------------------------
</a><a id="l92">92	//--- WRITING GRAPH for cities from departement = dpt
</a><a id="l93">93	//----------------------------------------------------------------- 
</a><a id="l94">94	    char filename[50];
</a><a id="l95">95	    sprintf(filename,"resuGraph_%d.dat",dpt);
</a><a id="l96">96	    FILE* fileOut = fopen(filename, "w");
</a><a id="l97">97	    for(int i=0; i&lt;cities-&gt;number; i++){
</a><a id="l98">98	      fprintf(fileOut, "%i %i\n", i, voisin[i]);
</a><a id="l99">99	    }
</a><a id="l100">100	    fclose(fileOut);
</a><a id="l101">101	
</a><a id="l102">102	    float taille_reseau_dpt = 0;
</a><a id="l103">103	    for(int i = 0; i &lt; cities-&gt;number; i++){ 
</a><a id="l104">104	      taille_reseau_dpt += poids(cities,i,voisin[i]);
</a><a id="l105">105	    }
</a><a id="l106">106	    taille_reseau += taille_reseau_dpt;
</a><a id="l107">107	
</a><a id="l108">108	//-----------------------------------------------------------------
</a><a id="l109">109	//--- DEALLOCATE arrays
</a><a id="l110">110	//-----------------------------------------------------------------
</a><a id="l111">111	    free(dansS);
</a><a id="l112">112	    free(voisin);
</a><a id="l113">113	    free(dist);
</a><a id="l114">114	  }
</a><a id="l115">115	
</a><a id="l116">116	
</a><a id="l117">117	//-----------------------------------------------------------------
</a><a id="l118">118	//--- READING bigger city from each departement
</a><a id="l119">119	//-----------------------------------------------------------------                             
</a><a id="l120">120	  cities = bigcitiesReader();
</a><a id="l121">121	
</a><a id="l122">122	  //TEMPS DE CALCUL: entrée dans l'algo
</a><a id="l123">123	  unsigned MKL_INT64 t2;
</a><a id="l124">124	  mkl_get_cpu_clocks(&t2);
</a><a id="l125">125	
</a><a id="l126">126	//-----------------------------------------------------------------
</a><a id="l127">127	//--- COMPUTING graph
</a><a id="l128">128	//-----------------------------------------------------------------
</a><a id="l129">129	  // allocation des variables
</a><a id="l130">130	  bool* dansS = malloc(cities-&gt;number*sizeof(bool));
</a><a id="l131">131	  int* voisin = malloc(cities-&gt;number*sizeof(int));
</a><a id="l132">132	  float* dist = malloc(cities-&gt;number*sizeof(float));
</a><a id="l133">133	
</a><a id="l134">134	  //Initialisation
</a><a id="l135">135	  dansS[0] = true;  //On démarre du sommet 0
</a><a id="l136">136	  dist[0] = 0;      //dist(0,0) = 0
</a><a id="l137">137	  for(int i = 0; i &lt; cities-&gt;number; i++){
</a></pre><pre style="display:inline-block;padding:5px;margin-right:3px;font-color:#AEAEAEk;font-size:11px;border-radius:12px;border:1px solid #dddddd; background:#fbfbfb">

LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l137">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(137,3)</a>
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
LOOP END
</pre>
<pre style="border-width:0px;"><a id="l138">138	    dansS[i] = false;
</a><a id="l139">139	    dist[i] = poids(cities,0,i);
</a><a id="l140">140	    voisin[i] = 0;
</a><a id="l141">141	  }
</a><a id="l142">142	  
</a><a id="l143">143	  //Itérations
</a><a id="l144">144	  int k = 0;
</a><a id="l145">145	  while(k &lt; cities-&gt;number - 2){
</a></pre><pre style="display:inline-block;padding:5px;margin-right:3px;font-color:#AEAEAEk;font-size:11px;border-radius:12px;border:1px solid #dddddd; background:#fbfbfb">

LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l145">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(145,3)</a>
   remark #15543: loop was not vectorized: loop with function call not considered an optimization candidate.

   LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l159">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(159,5)</a>
      remark #15523: loop was not vectorized: loop control variable j was found, but loop iteration count cannot be computed before executing the loop
   LOOP END
LOOP END
</pre>
<pre style="border-width:0px;"><a id="l146">146	    //Trouver i tels que (dansS[i]=false) et (dist[i] est minimal)
</a><a id="l147">147	    float minDist = FLT_MAX;
</a><a id="l148">148	    int i = 0;
</a><a id="l149">149	    for(int j = 1; j &lt; cities-&gt;number; j++){
</a></pre><pre style="display:inline-block;padding:5px;margin-right:3px;font-color:#AEAEAEk;font-size:11px;border-radius:12px;border:1px solid #dddddd; background:#fbfbfb">

LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l149">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(149,5)</a>
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l149">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(149,5)</a>
&lt;Remainder&gt;
LOOP END
</pre>
<pre style="border-width:0px;"><a id="l150">150	      if( dansS[j] == false){
</a><a id="l151">151	        if(dist[j] &lt; minDist){
</a><a id="l152">152	          minDist = dist[j];
</a><a id="l153">153	          i = j;
</a><a id="l154">154	        }
</a><a id="l155">155	      }
</a><a id="l156">156	    }
</a><a id="l157">157	    dansS[i] = true;
</a><a id="l158">158	    
</a><a id="l159">159	    for(int j = 0; j &lt; cities-&gt;number; j++){
</a><a id="l160">160	      if( dansS[j] == false ){
</a><a id="l161">161	        if( dist[j] &gt; poids(cities,i,j) ){
</a><a id="l162">162	          dist[j] = poids(cities,i,j);
</a><a id="l163">163	          voisin[j] = i;
</a><a id="l164">164	        }
</a><a id="l165">165	      }
</a><a id="l166">166	    }
</a><a id="l167">167	    k ++;
</a><a id="l168">168	  }
</a><a id="l169">169	//-----------------------------------------------------------------
</a><a id="l170">170	//--- GRAPH COMPUTED
</a><a id="l171">171	//-----------------------------------------------------------------
</a><a id="l172">172	  //TEMPS DE CALCUL: sortie de l'algo
</a><a id="l173">173	  unsigned MKL_INT64 t3;
</a><a id="l174">174	  mkl_get_cpu_clocks(&t3);
</a><a id="l175">175	  //TEMPS DE CALCUL TOTAL
</a><a id="l176">176	  double duration = (double)(t3 - t2 + time)/mkl_get_clocks_frequency()/1e9;
</a><a id="l177">177	
</a><a id="l178">178	//-----------------------------------------------------------------
</a><a id="l179">179	//--- WRITING GRAPH for big cities
</a><a id="l180">180	//-----------------------------------------------------------------
</a><a id="l181">181	  FILE* fileOut = fopen("resuGraph_bigcities.dat", "w");
</a><a id="l182">182	  for(int i = 0; i&lt;cities-&gt;number; i++){
</a></pre><pre style="display:inline-block;padding:5px;margin-right:3px;font-color:#AEAEAEk;font-size:11px;border-radius:12px;border:1px solid #dddddd; background:#fbfbfb">

LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l182">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(182,3)</a>
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
LOOP END
</pre>
<pre style="border-width:0px;"><a id="l183">183	    fprintf(fileOut, "%i %i\n", i, voisin[i]);
</a><a id="l184">184	  }
</a><a id="l185">185	  fclose(fileOut);
</a><a id="l186">186	  
</a><a id="l187">187	  for(int i = 0; i &lt; cities-&gt;number; i++){ 
</a></pre><pre style="display:inline-block;padding:5px;margin-right:3px;font-color:#AEAEAEk;font-size:11px;border-radius:12px;border:1px solid #dddddd; background:#fbfbfb">

LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l187">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(187,3)</a>
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
LOOP END
</pre>
<pre style="border-width:0px;"><a id="l188">188	    taille_reseau += poids(cities,i,voisin[i]);
</a><a id="l189">189	  }
</a><a id="l190">190	//-----------------------------------------------------------------
</a><a id="l191">191	//--- DEALLOCATE arrays
</a><a id="l192">192	//-----------------------------------------------------------------
</a><a id="l193">193	  free(dansS);
</a><a id="l194">194	  free(voisin);
</a><a id="l195">195	  free(dist);
</a><a id="l196">196	
</a><a id="l197">197	  free(cities-&gt;dpt);
</a><a id="l198">198	  free(cities-&gt;name);
</a><a id="l199">199	  free(cities-&gt;pop);
</a><a id="l200">200	  free(cities-&gt;lon);
</a><a id="l201">201	  free(cities-&gt;lat);
</a><a id="l202">202	  free(cities);
</a><a id="l203">203	
</a><a id="l204">204	//---------------------------------------------------------------
</a><a id="l205">205	//--- Réunion de tous les fichiers
</a><a id="l206">206	//---------------------------------------------------------------
</a><a id="l207">207	  FILE* citiesOutputFile = NULL;
</a><a id="l208">208	  citiesOutputFile = fopen("resuCities.dat","w");
</a><a id="l209">209	  FILE* graphOutputFile = NULL;
</a><a id="l210">210	  graphOutputFile = fopen("resuGraph.dat","w");
</a><a id="l211">211	  
</a><a id="l212">212	  if(citiesOutputFile != NULL && graphOutputFile != NULL){
</a><a id="l213">213	    int n = 0;
</a><a id="l214">214	    int nbVilles = 0;
</a><a id="l215">215	    for(int dpt = 1; dpt &lt; 95; dpt ++){
</a></pre><pre style="display:inline-block;padding:5px;margin-right:3px;font-color:#AEAEAEk;font-size:11px;border-radius:12px;border:1px solid #dddddd; background:#fbfbfb">

LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l215">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(215,5)</a>
   remark #15532: loop was not vectorized: compile time constraints prevent loop optimization. Consider using -O3.

   LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l234">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(234,9)</a>
      remark #15523: loop was not vectorized: loop control variable nbVilles was found, but loop iteration count cannot be computed before executing the loop
   LOOP END

   LOOP BEGIN at <a class="annot_link" href="main.c.annot.html#l245">/auto/d/de-sousa/SIM203/arbres-couvrants/main.c(245,9)</a>
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END
</pre>
<pre style="border-width:0px;"><a id="l216">216	      char citiesFilename[50];
</a><a id="l217">217	      sprintf(citiesFilename,"resuCities_%d.dat",dpt);
</a><a id="l218">218	      char graphFilename[50];
</a><a id="l219">219	      sprintf(graphFilename,"resuGraph_%d.dat",dpt);
</a><a id="l220">220	      //printf("== Merging cities file with population &gt;= %i and department = %i from %s ==\n", popMin, dpt, citiesFilename);
</a><a id="l221">221	      //printf("== Merging graph  file with population &gt;= %i and department = %i from %s ==\n", popMin, dpt, graphFilename);
</a><a id="l222">222	
</a><a id="l223">223	      FILE* citiesInputFile = NULL;
</a><a id="l224">224	      citiesInputFile = fopen(citiesFilename, "r");
</a><a id="l225">225	      FILE* graphInputFile = NULL;
</a><a id="l226">226	      graphInputFile = fopen(graphFilename, "r");
</a><a id="l227">227	      
</a><a id="l228">228	      if(citiesInputFile != NULL && graphInputFile != NULL){
</a><a id="l229">229	        char line[512];
</a><a id="l230">230	        const char s[2] = " ";
</a><a id="l231">231	        char *token;
</a><a id="l232">232	
</a><a id="l233">233	        nbVilles = 0;
</a><a id="l234">234	        while(fgets(line, 512, citiesInputFile) != NULL){
</a><a id="l235">235	          token = strtok(line, s);
</a><a id="l236">236	          int myPop = atoi(token);
</a><a id="l237">237	          token = strtok(NULL, s);
</a><a id="l238">238	          float myLon = atof(token);
</a><a id="l239">239	          token = strtok(NULL, s);
</a><a id="l240">240	          float myLat = atof(token);
</a><a id="l241">241	
</a><a id="l242">242	          fprintf(citiesOutputFile, "%i %f %f\n", myPop, myLon, myLat);
</a><a id="l243">243	          nbVilles ++;
</a><a id="l244">244	        }
</a><a id="l245">245	        while(fgets(line, 512, graphInputFile) != NULL){
</a><a id="l246">246	          token = strtok(line, s);
</a><a id="l247">247	          int villeA = atoi(token);
</a><a id="l248">248	          token = strtok(NULL, s);
</a><a id="l249">249	          int villeB = atoi(token);
</a><a id="l250">250	          fprintf(graphOutputFile, "%i %i\n", villeA+n, villeB+n);
</a><a id="l251">251	        }
</a><a id="l252">252	      }
</a><a id="l253">253	      n += nbVilles;
</a><a id="l254">254	      if (remove(citiesFilename) != 0) {
</a><a id="l255">255	        printf("The file %s is not deleted.",citiesFilename);
</a><a id="l256">256	      }
</a><a id="l257">257	      if (remove(graphFilename) != 0) {
</a><a id="l258">258	        printf("The file %s is not deleted.",graphFilename);
</a><a id="l259">259	      }
</a><a id="l260">260	    }
</a><a id="l261">261	  }
</a><a id="l262">262	//-----------------------------------------------------------------
</a><a id="l263">263	//--- FICHIERS DPT REUNIS DANS resuGraph.dat et resuCities.dat
</a><a id="l264">264	//-----------------------------------------------------------------
</a><a id="l265">265	
</a><a id="l266">266	  printf("\t%i cities: \n", nb_villes);
</a><a id="l267">267	  printf("Taille du reseau: %1.0f km\n",taille_reseau);
</a><a id="l268">268	  printf("Time is %fs\n ",duration);
</a><a id="l269">269	
</a><a id="l270">270	  return 0;
</a><a id="l271">271	}
</a></pre> </div></div>
<div class="footer">
<div class="title">Intel Corporation 2015
</div>
</div>
</body>
</html>
